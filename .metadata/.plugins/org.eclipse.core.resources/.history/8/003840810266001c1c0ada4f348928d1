package com.springboot.app.oauth.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;




//1.- CLASE DE CONFIGURACION DEL SERVIDOR DE CONFIGURACIÓN. SE ENCARGA DE: LOGIN POR PARTE DE OAUTH2, PROCESO DE CREACIÓN DE TOKEN JWT Y VALIDACIÓN. PARA ESTO SE USA EL AUTHENTICATION MANAGER.
@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {
	
//2.- SE HEREDA DE LA CLASE DE CONFIGURACIÓN AuthorizationServerConfigurerAdapter Y SE USAN 3 DE SUS MÉTODOS.
	@Override
	public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
		// TODO Auto-generated method stub
		super.configure(security);
	}
	
	
	//10.-CONFIGURACIÓN DE LOS CLIENTES(APPS FRONTEND) EN EL SERVIDOR DE AUTORIZACIÓN
	@Override
	public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
		//11.-withClient():SE REGISTRA UN CLIENTE EN MEMORIA. 
		//secret(): TAMBN SE REGISTRA SU CONTRASEÑA QUE ES ENCRIPTADA CON EL BEAN passwordEncoder Y EL MET.encode().
		//scopes("read","write"): SE CONFIGURA EL ALCANCE DE LA APPLICATION(LEER Y ESCRIBIR DATOS).
		//authorizedGrantTypes(): DEFINE EL TIPO DE CONSESIÓN QUE VA A TENER LA AUTENTICACIÓN.O SEA CÓMO SE VA A OBTENER EL TOKEN.EN ESTE CASO CON PASSWORD.
		//                        SE AGREGA TAMBN REFRESHTOKEN, PERMITE LA RENOVACIÓN DE TOKEN DESPUÉS DEL TIEMPO DE VALIDEZ DEL TOKEN.
		//accessTokenValiditySeconds(1HORA): TIEMPO DE VALIDEZ DEL TOKEN.
		//refreshTokenValiditySeconds(): TIEMPO DE REFRESH DEL TOKEN.
		
		//and(): CON AND() SE PUEDE CONFIGURAR OTRA APPLICATION CLIENTE.
		
		clients.inMemory().withClient("frontendapp")
						.secret(passwordEncoder.encode("12345")).scopes("read","write")
						.authorizedGrantTypes("password","refresh_token")
						.accessTokenValiditySeconds(3600)
						.refreshTokenValiditySeconds(3600);
							
	}
	
	
	//3.- EL authenticationManager ES REGISTRADO EN EL AuthorizationServerConfigurerAdapter.
	//AQUÍ SE CONFIGURA EL AuthenticationManager. 
	//TAMBN EL TOKEN STORAGE QUE ES DEL TIPO JWT.
	//TAMBN EL CONVERTER QUE GUARDA LOS DATOS DEL USUARIO EN EL TOKEN.
	@Override
	public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
		//4.- REGISTRO DE AuthenticationManager
		endpoints.authenticationManager(authenticationManager)
		
		//8.- SE CREA EL TOKEN STORAGE. EL COMPONENTE QUE GUARDA EL TOKEN CON LOS DATOS DEL accessTokenConverter
		.tokenStore(tokenStore())
		
		//5.- CONFIGURACIÓN DEL TOKEN STORAGE. COMPONENTE QUE GENERA Y GUARDA EL TOKEN
		.accessTokenConverter(accessTokenConverter());
		
	}
	
	
	//6.- ESTE MÉTODO LO CREA UNO Y DEBE SER PUBLIC Y SE CONFIGURA PARA QUE SEA DEL TIPO JWT.
	@Bean
	public JwtAccessTokenConverter accessTokenConverter() {
		JwtAccessTokenConverter tokenConverter = new JwtAccessTokenConverter();
		//7.- SE AGREGA CÓDIGO SECRETO QUE ES PARA LA FIRMA DEL TOKEN
		tokenConverter.setSigningKey("algún_código_secreto_aeiou");
		return tokenConverter;
	}
	
	//9.- SE CREA EL MÉTODO DE TIPO PUBLIC PARA DEVOLVER UN OBJ TOKENSTORE, AL CUAL SE LE PASA EL MÉTODO QUE DEVUELVE UN tokenConverter. 
	//POR LO TANTO EL TOKENSTORE RECIBE POR PARAMETRO EL MÉTODO QUE CREA AL TOKEN JWT CON SU RESPECTIVA INFORMACIÓN DE CONFIGURACIÓN.
	@Bean
	public JwtTokenStore tokenStore() {
		return new JwtTokenStore(accessTokenConverter());
	}

	//3.- AUTOWIRED DE BCryptPasswordEncoder Y AuthenticationManager
	@Autowired
	private BCryptPasswordEncoder passwordEncoder;
	@Autowired
	private AuthenticationManager authenticationManager;
}
